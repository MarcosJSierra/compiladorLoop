package kurokitsune.main;
import informacion.*;

import java_cup.runtime.Symbol;

action code {:
:}

parser code {:
    
    public Arbol arbolSintactico;


    @Override
    public void syntax_error(Symbol sy) {
        token t=(token)sy.value;
        done_parsing();
        report_error("Error sint√°ctico cerca de \""+ t.getCadena()+"\" ["+t.getRow()+" : "+t.getCol()+"]",null);
        
    }
:}

init with {: 
    arbolSintactico = new Arbol();
:};

terminal FINLINEA, REAL, VERDADERO, FALSO, RENTERO, RREAL, BOLEANO;
terminal CADENA, NULO, ESCRIBIR, LEER, DEVOLVER, CADENAENTERO, CADENAREAL, CADENABOLEANO;
terminal SENO, COSENO, TANGENTE, LOG, RAIZ, INSTANCIAR, ELIMINAR, SI, ENTONCES, SINO, DESDE;
terminal MIENTRAS, HACER, CLASE, PROPIEDADES, METODOS, PUBLICO, PRIVADO, PROTEGIDO, PUBLICA, PRIVADAS;
terminal PROTEGIDAS, PRINCIPAL, CONSTRUCTOR, DESTRUCTOR, EXTIENDE, INCLUIR, PUNTO, POTENCIA, COMPARACION, DOSPUNTOS;
terminal SUMA, RESTA, MULTI, DIVISION, APARENTESIS, CPARENTESIS, IGUAL, PORCENTAJE, COMA, ACORCHETEC, CCORCHETEC;
terminal ACORCHETE, CCORCHETE, AND, OR, ID;

terminal token ENTERO, STRING;


non terminal expr_list;
non terminal Nodo expr, expr_parte, seccion, INCLUIDOS;


precedence left SUMA, RESTA, INCLUIR;
precedence right MULTI, DIVISION;

start with expr_list;

expr_list ::= expr_list expr_parte:e {: 
                parser.arbolSintactico.agregarHijo(e);
            :}
            |expr_parte:e {:
                parser.arbolSintactico.agregarHijo(e);
            :}
            | seccion: s {:
                parser.arbolSintactico.agregarHijo(s);
            :}
            ;
seccion ::= INCLUIDOS:incl {:
                Nodo incluid= new Nodo(Nodo.TIPO_SECCION, Nodo.SEC_INCLUDE);
                incluid.agregarHijo(incl);
                RESULT=incluid;
            :}
            ;
INCLUIDOS ::= INCLUIR STRING:st {:RESULT=new Nodo(st.getCadena();)} 
            FINLINEA
            ;

expr_parte ::= expr:e {:
                Nodo expresion = new Nodo(Nodo.TIPO_EXPRESION,0);
                expresion.agregarHijo(e);
                RESULT=expresion;
            :} FINLINEA 
            ;
            
expr ::=  ENTERO:d {: RESULT=new Nodo(d.getEntero()); :}
        |expr:l SUMA expr:r {: 
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_SUMA);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz; 
        :}
        |expr:l RESTA expr:r {: 
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_RESTA);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        |expr:l MULTI expr:r {:
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_MULTI);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        |expr:l DIVISION expr:r {:
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_DIVISION);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        ;



