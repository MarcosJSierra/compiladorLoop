package kurokitsune.main;
import informacion.*;

import java_cup.runtime.Symbol;

action code {:
:}

parser code {:
    
    public Arbol arbolSintactico;


    @Override
    public void syntax_error(Symbol sy) {
        token t=(token)sy.value;
        done_parsing();
        report_error("Error sint√°ctico cerca de \""+ t.getCadena()+"\" ["+t.getRow()+" : "+t.getCol()+"]",null);
        
    }
:}

init with {: 
    arbolSintactico = new Arbol();
:};

terminal ENTERO, REAL, VERDADERO, FALSO, STRING, RENTERO, RREAL, BOLEANO;
terminal CADENA, NULO, ESCRIBIR, LEER, DEVOLVER, CADENAENTERO, CADENAREAL, CADENABOLEANO;
terminal SENO, COSENO, TANGENTE, LOG, RAIZ, INSTANCIAR, ELIMINAR, SI, ENTONCES, SINO, DESDE;
terminal MIENTRAS, HACER, CLASE, PROPIEDADES, METODOS, PUBLICO, PRIVADO, PROTEGIDO, PUBLICA, PRIVADAS;
terminal PROTEGIDAS, PRINCIAPL, CONSTRUCTOR, EXTIENDE, INCLUIR, PUNTO, POTENCIA, COMPARACION, FINLINEA, DOSPUNTOS;
terminal SUMA, RESTA, MULTI, DIVISION, APARENTESIS, CPARENTESIS, IGUAL, PORCENTAJE, COMA, ACORCHETEC, CCORCHETEC;
terminal ACOCHETE, CCORCHETE, AND, OR, ID;


non terminal expresion_list;
non terminal Nodo expresion, expresion_parte;

precedence left SUMA, RESTA;
precedence right MULTI, DIVISION;

start with expresion_list;

expr_list ::= expr_list expr_part:e {: 
                parser.arbolSintactico.agregarHijo(e);
            :}
            | expr_part:e {:
                parser.arbolSintactico.agregarHijo(e);
            :};
expr_part ::= expr:e {:
                Nodo expresion = new Nodo(Nodo.TIPO_EXPRESION,0);
                expresion.agregarHijo(e);
                RESULT=expresion;
            :} PCOMA;
            
expr ::=  ENTERO:d {: RESULT=new Nodo(d.getEntero()); :}
        |expr:l SUMA expr:r {: 
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_SUMA);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz; 
        :}
        |expr:l RESTA expr:r {: 
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_RESTA);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        |expr:l MULTI expr:r {:
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_MULTI);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        |expr:l DIVISION expr:r {:
            Nodo raiz = new Nodo(Nodo.TIPO_OPERADOR, Nodo.OP_MULTI);
            raiz.agregarHijo(l);
            raiz.agregarHijo(r);
            RESULT=raiz;
         :}
        ;



